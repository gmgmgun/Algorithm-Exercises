"""
-------------------------------------------
[문제 해석]
N을 입력 받아서 2 x N 크기를 1 x 2, 2 x 1 로 채우는 경우의 수

[접근]
1. 큰 부분(2 x N) 을 작은 부분(1 x 2, 2 x 1)으로 채우는 문제 -> DP
2. DP로 풀이
    - 점화식을 구한다
    - 2 x 1 을 채우는 경우의 수 = 1
    - 2 x 2 를 채우는 경우의 수 = 2
    - 2 x 3 를 채우는 경우의 수 = 3
    - 2 x 4 를 채우는 경우의 수 = 5
    ...
    - 2 x i 를 채우는 경우의 수는?
    dp[i] = dp[i -1] + dp[i - 2]
3. 점화식 결과를 메모라이징하며 계산

[카테고리]
동적 계획법(DP)

[리소스]
-------------------------------------------
"""

import sys

N = int(sys.stdin.readline())


def tile_squares(n):
    mod = 10007
    """
    나머지 연산에 10007를 사용하는 이유
    - 오버플로우 이슈를 회피하기 위해 정수 범위를 제한
    - 10007은 소수이기 때문에 나머지 연산 시 결과가 보다 균등하게 분포됨
    """

    # 1, 2 입력 시 점화식을 타지 않고 얼리 리턴
    if n == 1:
        return 1
    elif n == 2:
        return 2

    prev2, prev1 = 1, 2  # dp[i-2], dp[i-1]
    cur = 0

    for i in range(3, n + 1):  # 1, 2는 구해놓음
        cur = (prev1 + prev2) % mod  # dp[i] = dp[i-1] + dp[i-2]
        prev2 = prev1
        prev1 = cur

    return cur


print(tile_squares(N))